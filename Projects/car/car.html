<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>

<style>
body{
    margin: 0;
    overflow: hidden;
    background: darkgray;
    text-align: center;
}
.canvas{
    background: lightgray;
}
#save {
            position: absolute;
            top: 0px;
            left: 0px;
        
        }

        #discard {
            position: absolute;
            top: 0px;
            left: 40px;
 
        }
</style>
<body>
    <canvas class="canvas" id="canvas"></canvas>
    <input type="button" id="save" value="Save">
    <input type="button" id="discard" value="discard">

</body>
</html>
<script>
const canvas = document.getElementById("canvas")
canvas.width = window.innerWidth
let forward = false
let left = false
let right = false
let back = false

document.onkeydown = function(event){
    switch(event.key) {
        case 'd':
           left = true
            break;
            case 'w':
           forward = true
            break;
            case 'a':
            right = true
            break;
            case 's':
           back = true
            break;
    
    }


}
document.onkeyup = function(event){
    switch(event.key) {
        case 'd':
           left = false
            break;
            case 'w':
           forward = false
            break;
            case 'a':
            right = false
            break;
            case 's':
           back = false
            break;
    
    }
    

}
const ctx = canvas.getContext("2d")
const cars = [];
function generateCars(count) {

    const brain = createNeuralNetwork([10, 6, 4]);

 
    cars.push({
    carx:100,
    cary:500,
    carheight:50,
    carwidth:30,
    speed:0,
    maxspeed:5,
    friction:0.05,
    angle:0,
    acc:0.2,
    damaged:false,
    brain:brain 
            
        });
  
    }


generateCars(100);

let bestCarY = cars[0]

document.getElementById("save").onclick=function(){
    save()
}
document.getElementById("discard").onclick=function(){
    discard()
}




function update(car){
 
   if(forward == true){
   car.speed+=car.acc
   }
   if(back == true){
    car.speed-=car.acc
   }
   if(car.speed>car.maxspeed){
    car.speed = car.maxspeed
   }
   if(car.speed<-car.maxspeed/2){
    car.speed =-car.maxspeed/2
   }
   if (car.speed>0){
    car.speed-=car.friction
   }
   if (car.speed<0){
    car.speed+=car.friction
   }
   if(Math.abs(car.speed)<car.friction){
    car.speed =0
   }
  if(car.speed!=0){
    const flip=car.speed>0?1:-1;
    if(left == true){
    car.angle -= 0.03
   }
    if(right == true){
    car.angle +=0.03
   }
  }


  car.carx -= Math.sin(car.angle) * car.speed;
   car.cary -= Math.cos(car.angle) * car.speed;
   if (car.damaged == true) {
        prevCarX = 100
        prevCarY = 500
        prevangle = 0,
        car.carx = prevCarX;
        car.cary = prevCarY;
        car.angle = prevangle
    }
   
   }
   let borders = [];
   function draw(){
    ctx.lineWidth = 4
    ctx.beginPath()
    let startX = 200;
    let startY = 80;
    ctx.moveTo(startX, startY);
    let endX =  200; 
    let endY = 550; 
    ctx.lineTo(endX, endY);
    ctx.stroke()
    ctx.beginPath()
    let startX2 = 200;
    let startY2 = 80;
    ctx.moveTo(startX2, startY2);
    let endX2 =  1250; 
    let endY2 = 80; 
    ctx.lineTo(endX2, endY2);
    ctx.stroke()
    ctx.beginPath()
    let startX3 = 1250;
    let startY3 = 550;
    ctx.moveTo(startX3, startY3);
    let endX3 =  1250; 
    let endY3 = 80; 
    ctx.lineTo(endX3, endY3);
    ctx.stroke()
    ctx.beginPath()
    let startX4 = 1250;
    let startY4 = 550;
    ctx.moveTo(startX3, startY3);
    let endX4 =  200; 
    let endY4 = 550; 
    ctx.lineTo(endX4, endY4);
    ctx.stroke()
    ctx.beginPath()
    let startXout = 10;
    let startYout = 10;
    ctx.moveTo(startXout, startYout);
    let endXout =  1350; 
    let endYout = 10; 
    ctx.lineTo(endXout, endYout);
    ctx.stroke()
    ctx.beginPath()
    let startXout2 = 1350;
    let startYout2 = 10;
    ctx.moveTo(startXout2, startYout2);
    let endXout2 =  1340; 
    let endYout2 = 650; 
    ctx.lineTo(endXout2, endYout2);
    ctx.stroke()
    ctx.beginPath()
    let startXout3 = 1340;
    let startYout3 = 650;
    ctx.moveTo(startXout3, startYout3);
    let endXout3 =  10; 
    let endYout3 = 650; 
    ctx.lineTo(endXout3, endYout3);
    ctx.stroke()
    ctx.beginPath()
    let startXout4 = 10;
    let startYout4 = 10;
    ctx.moveTo(startXout4, startYout4);
    let endXout4 =  10; 
    let endYout4 = 650; 
    ctx.lineTo(endXout4, endYout4);
    ctx.stroke()
    innertopleft = {x:startX, y:startY}
    innerbottomleft = {x:endX, y:endY}
innertopup = {x:startX2, y:startY2}
innerbottomup = {x:endX2, y:endY2}
innertopright = {x:startX3, y:startY3}
innerbottomright = {x:endX3, y:endY3}
innertopdown = {x:startX4, y:startY4}
innerbottomdown = {x:endX4, y:endY4}
outerTopleft = {x:startXout, y:startYout}
outerBottomleft = {x:endXout, y:endYout}
outerTopup = {x:startXout2, y:startYout2}
outerBottomup = {x:endXout2, y:endYout2}
outerTopright = {x:startXout3, y:startYout3}
outerBottomright = {x:endXout3, y:endYout3}
outerTopdown = {x:startXout4, y:startYout4}
outerBottomdown = {x:endXout4, y:endYout4}
    
    borders = [
       [innertopleft,innerbottomleft,innertopup,innerbottomup,innertopright,innerbottomright,innertopdown,innerbottomdown],
       [outerTopleft, outerBottomleft, outerTopup, outerBottomup, outerTopright, outerBottomright, outerTopdown, outerBottomdown]
    ]

  
    }

    function createpolygon(car){
        
        const points = []
        const rad = Math.hypot(car.carwidth,car.carheight)/2
        const alpha = Math.atan2(car.carwidth,car.carheight)
     points.push({
        x:car.carx-Math.sin(car.angle-alpha)*rad,
        y:car.cary-Math.cos(car.angle-alpha)*rad

     });
     points.push({
        x:car.carx-Math.sin(car.angle+alpha)*rad,
        y:car.cary-Math.cos(car.angle+alpha)*rad

     });
     points.push({
        x:car.carx-Math.sin(Math.PI+car.angle-alpha)*rad,
        y:car.cary-Math.cos(Math.PI+car.angle-alpha)*rad,

     });
     points.push({
        x:car.carx-Math.sin(Math.PI+car.angle+alpha)*rad,
        y:car.cary-Math.cos(Math.PI+car.angle+alpha)*rad,

     });
     return points
    
    }
    
    function getintersection(A,B,C,D){ 
    const tTop=(D.x-C.x)*(A.y-C.y)-(D.y-C.y)*(A.x-C.x);
    const uTop=(C.y-A.y)*(A.x-B.x)-(C.x-A.x)*(A.y-B.y);
    const bottom=(D.y-C.y)*(B.x-A.x)-(D.x-C.x)*(B.y-A.y);

    
    if(bottom!=0){
        const t=tTop/bottom;
        const u=uTop/bottom;
        if(t>=0 && t<=1 && u>=0 && u<=1){
            return {
                x:lerp(A.x,B.x,t),
                y:lerp(A.y,B.y,t),
                offset:t
            }
        }
    }

    return null;
}


function sensors(car) {
    raycount = 10;
    let readings = [];
    raylength = 200;
    rayspread = Math.PI / 1;
    rays = [];

    for (let i = 0; i < raycount; i++) {
        const rayAngle = lerp(
            -rayspread / 2,
            rayspread / 2,
            i / (raycount - 1)
        ) + car.angle;

        const start = { x: car.carx, y: car.cary };
        const end = {
            x: car.carx - Math.sin(rayAngle) * raylength,
            y: car.cary - Math.cos(rayAngle) * raylength
        };

        rays.push({ start, end });
    }
    for (let i = 0; i < rays.length; i++) {
        let end = rays[i].end;
        if (readings[i]) {
            end = readings[i].end;
        }
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "yellow";
        ctx.moveTo(rays[i].start.x, rays[i].start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();

  
  
        
    }

    for (let i = 0; i < rays.length; i++) {
        readings.push(
            read(rays[i], borders)
        );
    
    }
    const brain = createNeuralNetwork([raycount, 6, 4]);
const offsets = readings.map(
    s => s == null ? 0 : 1 - s.offset
);

const outputs = brain.feedForward(offsets);

    if(outputs){
    forward=outputs[0]
    left=outputs[1]
    right=outputs[2]
    back=outputs[3]
}




    function read(ray, borders) {
    let touches = [];
    
    for (let i = 0; i < borders.length; i++) {
        for (let j = 0; j < borders[i].length; j += 2) {
            const touch = getintersection(
                ray.start,
                ray.end,
                borders[i][j],
                borders[i][j + 1]
            );

            if (touch) {
                
                touches.push(touch);
             
              
                ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(touch.x, touch.y,5,0,6);
        ctx.fill();
   
            }
        }
    }

    if (touches.length === 0) {
        return null;
    } else {
        const offsets = touches.map((e) => e.offset);
        const minoffset = Math.min(...offsets);
        return touches.find((e) => e.offset === minoffset);
       
    }

  
}
 
}


function createNeuralNetwork(neuronCounts) {
    const levels = [];
    for (let i = 0; i < neuronCounts.length - 1; i++) {
        levels.push(createLevel(neuronCounts[i], neuronCounts[i + 1]));
    }

    return {
        levels,

        feedForward(givenInputs) {
            let outputs = feedForwardLevel(givenInputs, this.levels[0]);
            for (let i = 1; i < this.levels.length; i++) {
                outputs = feedForwardLevel(outputs, this.levels[i]);
            }
            return outputs;
        },
    };
}

function createLevel(inputCount, outputCount) {
    const level = {
        inputs: new Array(inputCount),
        outputs: new Array(outputCount),
        biases: new Array(outputCount),
        weights: [],
    };

    for (let i = 0; i < inputCount; i++) {
        level.weights[i] = new Array(outputCount);
    }

    randomize(level);

    return level;
}

function randomize(level) {
    for (let i = 0; i < level.inputs.length; i++) {
        for (let j = 0; j < level.outputs.length; j++) {
            level.weights[i][j] = Math.random() * 2 - 1;
        }
    }

    for (let i = 0; i < level.biases.length; i++) {
        level.biases[i] = Math.random() * 2 - 1;
    }
}

function feedForwardLevel(givenInputs, level) {
    for (let i = 0; i < level.inputs.length; i++) {
        level.inputs[i] = givenInputs[i];
    }

    for (let i = 0; i < level.outputs.length; i++) {
        let sum = 0;
        for (let j = 0; j < level.inputs.length; j++) {
            sum += level.inputs[j] * level.weights[j][i];
        }

        if (sum > level.biases[i]) {
            level.outputs[i] = 1;
        } else {
            level.outputs[i] = 0;
        }
    }

    return level.outputs;
}


function lerp(start, end, t) {
    return start * (1 - t) + end * t;
}
function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function polysIntersect(poly1, poly2) {
    for (let i = 0; i < poly1.length; i++) {
        for (let j = 0; j < poly2.length; j += 2) {
            const touch = getintersection(
                poly1[i],
                poly1[(i + 1) % poly1.length],
                poly2[j],
                poly2[j + 1]
            );
           
            if (touch) {
                return true;
            }
        }
    }
    return false;
}

function damaged(points) {
     
    for (let i = 0; i < borders.length; i++) {
        if (polysIntersect(points, borders[i])) {
            return true;
        }
    }
    return false;
}
function save(){
    const minCarX = cars.reduce((min, car) => (car.carx < min ? car.carx : min), Infinity);
        const minCarY = cars.reduce((min, car) => (car.cary < min ? car.cary : min), Infinity);

        const bestCarX = cars.find((car) => car.carx === minCarX);
        const bestCarY = cars.find((car) => car.cary === minCarY);
        if (bestCarY) {
                localStorage.setItem("bestbrain", JSON.stringify(bestCarY.brain));
                console.log(bestCarY.brain);
            } else {
                console.error("Unable to save best brain to local storage. No valid brain found.");
            }
        

}
function discard(){
    localStorage.removeItem("bestbrain")
}
 

 
    function animate() {  
        clearCanvas();
        canvas.height = window.innerHeight;
        draw()

        for (let o=0;o<cars.length;o++){
        const minCarX = cars.reduce((min, car) => (car.carx < min ? car.carx : min), Infinity);
        const minCarY = cars.reduce((min, car) => (car.cary < min ? car.cary : min), Infinity);

        const bestCarX = cars.find((car) => car.carx === minCarX);
        const bestCarY = cars.find((car) => car.cary === minCarY);
            update(cars[o]);
            const points = createpolygon(cars[o])
            ctx.beginPath()
            ctx.moveTo(points[0].x,points[0].y)
        

    

for (let i=1;i<points.length;i++)
{
    ctx.lineTo(points[i].x,points[i].y)
}
if (damaged(points)) {
ctx.fillStyle = "gray";
cars[o].damaged = true 

} else {
ctx.fillStyle = "blue";  
cars[o].damaged = false

}

ctx.fill()

sensors(bestCarY)

        }
         



  



      


        
    requestAnimationFrame(animate);

}

animate();




</script>